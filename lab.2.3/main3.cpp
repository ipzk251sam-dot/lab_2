#include <iostream>
#include <string>

using namespace std;

// 1. Додаємо слово 'final'. Воно забороняє будь-якому іншому класу наслідувати Authenticator.
// Це виконує умову "незалежно від класів, що його наслідують".
class Authenticator final {
private:
    // 2. Робимо конструктор ПРИВАТНИМ! 
    // Тепер ніхто в програмі не зможе написати 'new Authenticator()'
    Authenticator() {
        cout << "[Система] Створено єдиний екземпляр Authenticator!\n";
    }

public:
    // 3. Забороняємо копіювання об'єкта, щоб ніхто випадково не зробив клон нашого Одинака
    Authenticator(const Authenticator&) = delete;
    Authenticator& operator=(const Authenticator&) = delete;

    // 4. Головний метод, який повертає наш єдиний екземпляр
    static Authenticator& getInstance() {
        // У сучасному C++ (починаючи з C++11) створення такої статичної змінної 
        // автоматично є ПОТОКОБЕЗПЕЧНИМ (thread-safe). Нам не треба писати складні блокування (mutex).
        static Authenticator instance; 
        return instance;
    }

    // Звичайний метод нашого класу для демонстрації роботи
    void login(string username) {
        cout << "Користувач '" << username << "' успішно авторизований.\n";
    }
};

// =========================================================
// ГОЛОВНИЙ МЕТОД (Клієнтський код)
// =========================================================
int main() {
    // Встановлюємо кирилицю для консолі
    setlocale(LC_ALL, "Ukrainian");

    cout << "=== Патерн Одинак (Singleton) ===\n\n";

    // Якщо ми спробуємо розкоментувати рядок нижче, програма видасть помилку, 
    // бо конструктор приватний. І це саме те, що нам треба!
    // Authenticator myAuth = new Authenticator(); 

    // Крок 1: Звертаємося до Одинака вперше. 
    // Саме зараз він створиться (виведеться повідомлення в консоль).
    cout << "Спроба 1: Отримуємо доступ до Authenticator...\n";
    Authenticator& auth1 = Authenticator::getInstance();
    auth1.login("Студент_Іван");

    // Крок 2: Звертаємося вдруге.
    // Новий об'єкт НЕ створиться, ми отримаємо той самий.
    cout << "\nСпроба 2: Отримуємо доступ до Authenticator ще раз...\n";
    Authenticator& auth2 = Authenticator::getInstance();
    auth2.login("Викладач_Петро");

    // Крок 3: Перевіряємо, чи це дійсно ОДИН І ТОЙ САМИЙ об'єкт.
    // Для цього просто виведемо їхні адреси в пам'яті комп'ютера.
    cout << "\n--- Перевірка адрес у пам'яті ---\n";
    cout << "Адреса auth1: " << &auth1 << endl;
    cout << "Адреса auth2: " << &auth2 << endl;

    if (&auth1 == &auth2) {
        cout << "\nУСПІХ! Обидві змінні вказують на одну й ту саму адресу в пам'яті.\n";
        cout << "Патерн Одинак працює ідеально!\n";
    }

    return 0;
}